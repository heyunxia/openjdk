#
# Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
#

#
# modules           Target to build jigsaw modules images.
# 
# This target will build the modules images taking the jdk modules
# under the $outputdir/modules directory. For incremental build,
# make sure that $outputdir/modules is up-to-date (i.e. build
# make/modules/Makefile before invoking the "modules" target).
# 
# The following modules images are created:
#
# jre-base-image:   Minimal Java runtime environment
# jre-module-image: Full Java runtime environment with all JRE modules
#                   installed
# jdk-module-image: jre-module-image with all JDK modules installed
#                   i.e. full Java development kit
#
# TODO: we may not need jdk-base-image to build. It is for
#       convenience for the base image testing that at least
#       needs javac in it.
#
# jdk-base-image:   jre-base-image with the language tool modules
#                   installed.
#                   
#
MODULE_IMAGES_DIR = $(ABS_OUTPUTDIR)
JDK_MODULE_IMAGE_DIR = $(MODULE_IMAGES_DIR)/jdk-module-image
JRE_MODULE_IMAGE_DIR = $(MODULE_IMAGES_DIR)/jre-module-image
JDK_BASE_IMAGE_DIR = $(MODULE_IMAGES_DIR)/jdk-base-image
JRE_BASE_IMAGE_DIR = $(MODULE_IMAGES_DIR)/jre-base-image

#
# TODO:
# 1. Any other sanity check to perform?
# 2. Trim out any extra files not for the jre shipment.
#    (Note the jdk WILL want the jre image before this trimming)
# 3. Post process the image (strips and mcs on Elf files we are shipping)
#    (Note the jdk WILL want the jre image before this processing)
# 4. Sign security jars and export policy files
# 5. Java DB, demos/samples module not installed yet 
# 6. man pages - should go in the module of the tool?
#
# Open issues that need further investigation:
# 1. Classes in jre/lib/ext/dnsns.jar are currently put in jre/lib/jndi-dns
#    module.  META-INF/services file is not installed.
# 2. Signed jars
#    For JDK build, signed jars are copied to the build.
#    All jars in the module image are unsigned.
# 3. sparcv9 image is installed on top of a sparc image

#
# Targets.
#
MODULE_TARGET_SUFFIX=
ifeq ($(PLATFORM), solaris)
  ifeq ($(ARCH_DATA_MODEL), 64)
    MODULE_TARGET_SUFFIX=-sol64
  endif
endif


modules modules-clobber::
	@$(ECHO) ">>>Making "$@" @ `$(DATE)` ..."

#
# jdk-xxx-image depends on jre-xxx-image
#
# Build jdk-xxx-image target before jre-xxx-image target
# so that jre-xxx-image will be made only once
#
modules:: sanity-images post-sanity-images \
	  gen-pkgs \
	  jdk-base-image$(MODULE_TARGET_SUFFIX) \
	  jre-base-image$(MODULE_TARGET_SUFFIX) \
	  jdk-module-image$(MODULE_TARGET_SUFFIX) \
	  jre-module-image$(MODULE_TARGET_SUFFIX) \
	  post-image-build

###### RULES for License and doc files

# JDK files
$(JDK_BASE_IMAGE_DIR)/%: $(SHARE_JDK_DOC_SRC)/%
	$(process-doc-file)

# Removes LICENSE_VERSION or not
ifdef LICENSE_VERSION
$(JDK_BASE_IMAGE_DIR)/%: $(SHARE_JDK_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)
$(JDK_BASE_IMAGE_DIR)/%64: $(SHARE_JDK_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)
else
$(JDK_BASE_IMAGE_DIR)/%: $(SHARE_JDK_DOC_SRC)/%
	$(process-doc-file)

$(JDK_BASE_IMAGE_DIR)/%64: $(SHARE_JDK_DOC_SRC)/%
	$(process-doc-file)
endif

# JRE files
$(JRE_BASE_IMAGE_DIR)/%: $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)

# Add $(TEXT_SUFFIX) suffix
ifdef TEXT_SUFFIX
$(JRE_BASE_IMAGE_DIR)/%$(TEXT_SUFFIX): $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)
endif

# Removes LICENSE_VERSION or not
ifdef LICENSE_VERSION
$(JRE_BASE_IMAGE_DIR)/%: $(SHARE_JRE_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)

$(JRE_BASE_IMAGE_DIR)/%64: $(SHARE_JRE_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)
else
$(JRE_BASE_IMAGE_DIR)/%: $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)

$(JRE_BASE_IMAGE_DIR)/%64: $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)
endif

# JDK files
$(JDK_MODULE_IMAGE_DIR)/%: $(SHARE_JDK_DOC_SRC)/%
	$(process-doc-file)

# Removes LICENSE_VERSION or not
ifdef LICENSE_VERSION
$(JDK_MODULE_IMAGE_DIR)/%: $(SHARE_JDK_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)
$(JDK_MODULE_IMAGE_DIR)/%64: $(SHARE_JDK_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)
else
$(JDK_MODULE_IMAGE_DIR)/%: $(SHARE_JDK_DOC_SRC)/%
	$(process-doc-file)

$(JDK_MODULE_IMAGE_DIR)/%64: $(SHARE_JDK_DOC_SRC)/%
	$(process-doc-file)
endif

# JRE files
$(JRE_MODULE_IMAGE_DIR)/%: $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)

# Add $(TEXT_SUFFIX) suffix
ifdef TEXT_SUFFIX
$(JRE_MODULE_IMAGE_DIR)/%$(TEXT_SUFFIX): $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)
endif

# Removes LICENSE_VERSION or not
ifdef LICENSE_VERSION
$(JRE_MODULE_IMAGE_DIR)/%: $(SHARE_JRE_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)

$(JRE_MODULE_IMAGE_DIR)/%64: $(SHARE_JRE_DOC_SRC)/%$(LICENSE_VERSION)
	$(process-doc-file)
else
$(JRE_MODULE_IMAGE_DIR)/%: $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)

$(JRE_MODULE_IMAGE_DIR)/%64: $(SHARE_JRE_DOC_SRC)/%
	$(process-doc-file)
endif

#
# Create a module library for the specified image location
define create-module-library
image=$(strip $1); \
mlib=$(MODULE_IMAGES_DIR)/$$image/lib/modules; \
$(ECHO) "Creating module library $$mlib" ; \
$(HOST_JMOD_CMD) create -N -L $$mlib
endef

# Copy module content to the module image
#   $1 - image location
#   $2 - module name
#
define copy-module-content
image=$(strip $1); m=$(strip $2); \
javahome=$(MODULE_IMAGES_DIR)/$$image; \
for d in bin lib ; do \
   if [ -d $$m/$$d ] ; then \
       $(CP) -rf $(ABS_MODULES_DIR)/$$m/$$d $$javahome; \
   fi ; \
done 
endef

#
# Copy JRE image to the dest
# $1 - jre image location
# $2 - dest location
#
# Shall investigate if we can eliminate the dependency on this special
# copy of the lib/dll files.
# Probably better to copy these files to part of the jdk.base.tools module
# Also, need to copy jawt.lib. 
# 
# Should *_SUFFIX variable either have "." or not dot?
#
define copy-jre-image
from=$(strip $1); dest=$(strip $2); \
($(CD) $(MODULE_IMAGES_DIR)/$$from && $(FIND) . -depth -print \
              | $(CPIO) -pdum $(MODULE_IMAGES_DIR)/$$dest) ; \
if [ -d "$(ABS_MODULES_DIR)/jdk.boot/include" ] ; then \
   $(CP) -rf $(ABS_MODULES_DIR)/jdk.boot/include $(MODULE_IMAGES_DIR)/$$dest; \
fi
endef

#
# Install jigsaw module 
#   $1 - image location
#   $2 - module name
define install-jigsaw-module
image=$(strip $1); m=$(strip $2); \
mlib=$(MODULE_IMAGES_DIR)/$$image/lib/modules; \
mid=`$(HOST_JMOD_CMD) ls -L $$mlib $$m | $(GREP) -v '#'` ; \
if [ "x$$mid" = "x" ] ; then \
   $(ECHO) "Installing module $$m in $$image" ; \
   $(CD) $(ABS_MODULES_DIR) && \
   if [ -d $$m/resources ] ; then \
      $(HOST_JMOD_CMD) install $$m/classes -r $$m/resources -L $$mlib $$m || exit 1; \
   else \
      $(HOST_JMOD_CMD) install $$m/classes -L $$mlib $$m || exit 1; \
   fi ; \
   $(call copy-module-content,$1,$2) ; \
else \
   $(ECHO) "Module $$m already installed in $$image" ; \
fi
endef

# Modules for JDK only
MODULES_LIST_DIR = $(MODULES_TEMPDIR)/classlist
JDK_MODULES = $(MODULES_LIST_DIR)/jdk.modules.list
JRE_MODULES = $(MODULES_LIST_DIR)/jdk.jre.modules.list
JDK_BASE_MODULES = $(MODULES_LIST_DIR)/jdk.base.tools.modules.list
JRE_BASE_MODULES = $(MODULES_LIST_DIR)/jdk.base.modules.list

# Rules for building packages
include $(BUILDDIR)/common/BuildPackages.gmk

PKG_TYPES = jmod-pkgs
DEBIAN := $(shell \
               if [ -f /etc/debian_version ] ; then \
                  $(ECHO) true; \
               else \
                  $(ECHO) false; \
               fi)


ifeq ($(DEBIAN), true)
PKG_TYPES += deb-pkgs
endif

gen-pkgs: $(PKG_TYPES)


%-setup:
	$(RM) -r $(MODULE_IMAGES_DIR)/$*
	$(MKDIR) $(MODULE_IMAGES_DIR)/$*

jdk-base-image: jre-base-image \
                jdk-base-image-setup \
		jdk-base-image-docfiles
	$(call copy-jre-image,jre-base-image,$@)
	@for jm in `$(NAWK) '{print $$1}' $(JDK_BASE_MODULES)` ; do \
	    $(call install-jigsaw-module,$@,$$jm) ; \
	done

jre-base-image: jre-base-image-setup \
		jre-base-image-docfiles
	$(call create-module-library,$@)
	@for jm in `$(NAWK) '{print $$1}' $(JRE_BASE_MODULES)` ; do \
	    $(call install-jigsaw-module,$@,$$jm) ; \
	done

# 64-bit solaris jre image contains only the 64-bit add-on files.
# FIXME: should there be two sets of modules (one for sparc and one for sparcv9)?
jdk-base-image-sol64: jre-base-image-sol64 \
                      jdk-base-image-setup \
		      $(LICENSE_DOCLIST_JRE:%=$(JDK_BASE_IMAGE_DIR)/%64) 
	@# Temporary workaround - install sparcv9 modules 
	$(call copy-jre-image,jre-base-image,jdk-base-image)
	@for jm in `$(NAWK) '{print $$1}' $(JDK_BASE_MODULES)` ; do \
	    $(call install-jigsaw-module,jdk-base-image,$$jm) ; \
	done

jre-base-image-sol64: jre-base-image-setup \
		      $(LICENSE_DOCLIST_JRE:%=$(JRE_BASE_IMAGE_DIR)/%64) 
	@# Temporary workaround - install sparcv9 modules 
	$(call create-module-library,jre-base-image)
	@for jm in `$(NAWK) '{print $$1}' $(JRE_BASE_MODULES)` ; do \
	    $(call install-jigsaw-module,jre-base-image,$$jm) ; \
	done

jdk-base-image-docfiles: $(LICENSE_DOCLIST_JDK:%=$(JDK_BASE_IMAGE_DIR)/%) \
	                 $(OTHER_DOCLIST_JDK:%=$(JDK_BASE_IMAGE_DIR)/%)

jre-base-image-docfiles: $(LICENSE_DOCLIST_JRE:%=$(JRE_BASE_IMAGE_DIR)/%) \
	                 $(OTHER_DOCLIST_JRE:%=$(JRE_BASE_IMAGE_DIR)/%) \
                         $(JRE_NAMECHANGE_DOCLIST:%=$(JRE_BASE_IMAGE_DIR)/%$(TEXT_SUFFIX))

jdk-module-image: jre-module-image \
                  jdk-module-image-setup \
		  jdk-module-image-docfiles
	$(call copy-jre-image,jre-module-image,$@)
	@for jm in `$(NAWK) '{print $$1}' $(JDK_MODULES)` ; do \
	    $(call install-jigsaw-module,$@,$$jm); \
	done

jre-module-image: jre-module-image-setup \
  		  jre-module-image-docfiles
	$(call create-module-library,$@)
	@for jm in `$(NAWK) '{print $$1}' $(JRE_MODULES)` ; do \
	    $(call install-jigsaw-module,$@,$$jm); \
	done

# 64-bit solaris jre image contains only the 64-bit add-on files.
# FIXME: should there be two sets of modules (one for sparc and one for sparcv9)?
jdk-module-image-sol64: jre-module-image-sol64 \
                        jdk-module-image-setup \
		        jdk-module-image-docfiles \
		        $(LICENSE_DOCLIST_JRE:%=$(JDK_MODULE_IMAGE_DIR)/%64) 
	@# Temporary workaround - install sparcv9 modules 
	$(call copy-jre-image,jre-module-image,jdk-module-image)
	@for jm in `$(NAWK) '{print $$1}' $(JDK_MODULES)` ; do \
	    $(call install-jigsaw-module,jdk-module-image,$$jm); \
	done

jre-module-image-sol64: jre-module-image-setup \
		        jre-module-image-docfiles \
		        $(LICENSE_DOCLIST_JRE:%=$(JRE_MODULE_IMAGE_DIR)/%64) 
	@# Temporary workaround - install sparcv9 modules 
	$(call create-module-library,jre-module-image)
	@for jm in `$(NAWK) '{print $$1}' $(JRE_MODULES)` ; do \
	    $(call install-jigsaw-module,jre-module-image,$$jm); \
	done

jdk-module-image-docfiles: $(LICENSE_DOCLIST_JDK:%=$(JDK_MODULE_IMAGE_DIR)/%) \
  	                   $(OTHER_DOCLIST_JDK:%=$(JDK_MODULE_IMAGE_DIR)/%)

jre-module-image-docfiles: $(LICENSE_DOCLIST_JRE:%=$(JRE_MODULE_IMAGE_DIR)/%) \
	                   $(OTHER_DOCLIST_JRE:%=$(JRE_MODULE_IMAGE_DIR)/%) \
                           $(JRE_NAMECHANGE_DOCLIST:%=$(JRE_MODULE_IMAGE_DIR)/%$(TEXT_SUFFIX))

post-image-build:
	@# Make sure all directories are read/execute for everyone
	@# chmod complains arg list too long; so do it one by one
	$(CHMOD) a+rx `$(FIND) $(JDK_BASE_IMAGE_DIR) -type d`
	$(CHMOD) a+rx `$(FIND) $(JRE_BASE_IMAGE_DIR) -type d`
	$(CHMOD) a+rx `$(FIND) $(JDK_MODULE_IMAGE_DIR) -type d`
	$(CHMOD) a+rx `$(FIND) $(JRE_MODULE_IMAGE_DIR) -type d`

######################################################
# clobber
######################################################
modules-clobber::
	$(RM) -r $(MODULE_IMAGES_DIR)

modules modules-clobber::
	@$(ECHO) ">>>Finished making "$@" @ `$(DATE)` ..."
	@$(java-vm-cleanup)

.PHONY: modules modules-clobber gen-pkgs \
	jre-base-image$(MODULE_TARGET_SUFFIX) \
	jdk-base-image$(MODULE_TARGET_SUFFIX) \
	jre-module-image$(MODULE_TARGET_SUFFIX) \
	jdk-module-image$(MODULE_TARGET_SUFFIX)

# Force rule
FRC:

