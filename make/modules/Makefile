#
# Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

BUILDDIR = ..
PRODUCT  = modules
include $(BUILDDIR)/common/Defs.gmk

CLASSANALYZER_JAR_FILE = $(BUILDTOOLJARDIR)/classanalyzer.jar
MODULES_CONFIG = modules.config
MODULES_GROUP = modules.group
MODULES_PROPERTIES = modules.properties
DEP_CONFIG = jdk.depconfig
OPTIONAL_DEP_CONFIG = optional.depconfig

#
# Modularizing the JDK
# - Post jdk build process until the source tree is restructured
#   for modules build
# - <outputdir>/modules/<module> will be created for each module
# - modules are installed in <outputdir>/lib/modules (jigsaw module
#   library)
#
# Steps:
# 0. During jdk build before this makefile is invoked, classes,
#    resource files, and other non-class files such as native libraries,
#    properties file, images, etc are created.
#
#    Non-class files are copied to <outputdir>/submodules/<MODULE>
#    directory in this step to prepare for the post-build modularization.
#
#    The MODULE variable defined in other makefiles specifies
#    the lowest-level module that the non-class files belong to.
#    The name might or might not be the same as the name of the modules
#    in the resulting <outputdir>/modules directory.
#
# 1. Run ClassAnalyzer tool to analyze all jdk classes and generate
#    class list for all modules and also perform dependency analysis.
#
#    Input configuration files :-
#
#    modules.config : defines the low-level modules and specifies
#       what classes and resource files each module includes.
#    modules.group  : defines the module groups and its members.
#    jdk.depconfig : lists the dynamic dependencies including
#       use of reflection Class.forName and JNI FindClass and
#       service provider.
#    optional.depconfig : lists the optional dependencies
#
#    For incremental build, ClassAnalyzer tool will only parse files
#    that are updated since the last build (by comparing the timestamp
#    of modules.list).
#
# 2. Compile module-info.java files generated by the ClassAnalyzer tool.
#    (only updated module-info.java files for incremental build)
#
# 3. Modularize the JDK.  It creates one directory for each module
#    (<outputdir>/modules/<module>) based on the output files
#    from (1) and also creates a jigsaw module library.
#
#    a. Run Modularizer tool to copy files listed in $m.classlist and
#       $m.resources to <outputdir>/modules/$m/classes and
#       <outputdir>/modules/$m/resources respectively.
#
#       For incremental build, Modularizer tool will only copy files
#       that are modified since the last run (by comparing the timestamp
#       between the source and destination).
#
#    b. copy all non-class files from its members (such as bin, lib, include)
#       to <outputdir>/modules/$m.
#
#       modules.list lists the modules to be created for the modules
#       build and its members.
#
#    c. Install each module in the jigsaw module library
#
ORB_IDL=$(MODULEPATH_DIR)/$(IDLJ_MODULE)/etc/orb.idl
IR_IDL=$(MODULEPATH_DIR)/$(IDLJ_MODULE)/etc/ir.idl


all: $(MODULES_LIST) module-info-classes $(ORB_IDL) $(IR_IDL) modularize


# clean modules build
define clean-build
$(RM) -rf $(JIGSAW_MODULE_LIB)
$(RM) -rf $(MODULEINFO_DIR)
$(RM) -rf $(MODULEPATH_DIR)
$(RM) -rf $(MODULES_TEMPDIR)
$(ECHO) "" > $(MODULES_UPDATE_MARKER)
endef

# Do a clean modules build if any of the input modules.config
# files is modified.
$(MODULES_LIST):: $(MODULES_CONFIG) $(MODULES_GROUP) \
                 $(MODULES_PROPERTIES) \
                 $(DEP_CONFIG) $(OPTIONAL_DEP_CONFIG) \
                 $(CLASSANALYZER_JAR_FILE)
	$(clean-build)

#
# Run class analyzer to analyze the jdk.  For incremental build,
# only recompiled classes are parsed.  module-info.java source
# files for all or just the updated modules are generated.
$(MODULES_LIST):: $(MODULES_UPDATE_MARKER)
	@$(ECHO) ">>>Making "$@" @ `$(DATE)` ..."
	$(clean-build)
	$(HOST_JAVA_CMD) \
                -jar $(CLASSANALYZER_JAR_FILE) \
                -jdkhome $(OUTPUTDIR) \
                -config $(MODULES_CONFIG) \
                -config $(MODULES_GROUP) \
                -depconfig $(DEP_CONFIG) \
                -depconfig $(OPTIONAL_DEP_CONFIG) \
                -properties $(MODULES_PROPERTIES) \
                -version $(MODULE_VERSION) \
                -base $(BASE_MODULE) \
                -output $(MODULE_CLASSLIST_DIR) \
                -moduleinfo $(MODULEINFO_SRC)
	@$(java-vm-cleanup)
	@$(ECHO) ">>>Finished making "$@" @ `$(DATE)` ..."

# Rules for compiling module-info.java
# -Xbootclasspath is needed to compile module-info.java
# if JDK_HOST_PATH is a legacy jdk and the main class
# for some modules are not in rt.jar (or $outputdir/classes)
BOOTCLASSPATH := $(shell bcp="$(OUTPUTDIR)/classes"; \
                      jfiles=`$(FIND) $(OUTPUTDIR)/lib -name \*.jar -print` ; \
	              for jf in  $$jfiles ; do \
                          if [ -f $$jf ] ; then \
                              bcp="$$bcp$(CLASSPATH_SEPARATOR)$$jf"; \
                          fi \
                      done; \
                      $(ECHO) $$bcp)
JAVAC_CMD := $(HOST_JAVAC_CMD) \
                    -Xbootclasspath:"$(BOOTCLASSPATH)" \
                    -modulepath $(MODULEPATH_DIR) \
                    -sourcepath $(MODULEINFO_SRC)
FILES_java := $(shell $(NAWK) '{print $$1 "/module-info.java"}' ${MODULES_LIST})
CLASSDESTDIR = $(MODULEPATH_DIR)

include $(BUILDDIR)/common/Classes.gmk

# Compile module-info.java 
# javac depends on the jigsaw module library to exist
module-info-classes:
	if [ ! -d $(JIGSAW_MODULE_LIB) ] ; then \
	   $(HOST_JMOD_CMD) create -N $(JMOD_CREATE_ARGS) -L $(JIGSAW_MODULE_LIB) ; \
	fi
	$(MAKE) classes || exit 1

$(MODULEPATH_DIR)/%/module-info.class: $(MODULEINFO_SRC)/%/module-info.java
	@$(add-java-file)

#  copy module-info.class from modules/$m directory to
#  modules/$m/classes. Default module-info destination for javac
#  multi-module path is <modulepath>/<module>.
$(MODULEPATH_DIR)/%/classes/module-info.class: $(MODULEPATH_DIR)/%/module-info.class
	@$(install-non-module-file)

#
# Modularize JDK and install the modules in the jigsaw library
#
# This "modularize" target can be used as an interim solution
# for incremental build when there is no class added or removed
# since the last run of classanalyzer.
#
modularize:
	@$(ECHO) ">>>Making "$@" @ `$(DATE)` ..."
	$(HOST_JAVA_CMD) \
                -cp $(CLASSANALYZER_JAR_FILE) \
                com.sun.classanalyzer.Modularizer \
                -jdkhome $(OUTPUTDIR) \
                -classlistdir $(MODULE_CLASSLIST_DIR) \
                -modulepath $(ABS_MODULEPATH_DIR)
	@$(RM) -rf $(JIGSAW_MODULE_LIB)
	@$(HOST_JMOD_CMD) create -N $(JMOD_CREATE_ARGS) -L $(JIGSAW_MODULE_LIB)
	@$(java-vm-cleanup)
	$(MAKE) `$(NAWK) '{print "$(JIGSAW_MODULE_LIB)/" $$1 "/$(MODULE_VERSION)/info" }' $(MODULES_LIST)` || exit 1
	@$(ECHO) ">>>Finished making "$@" @ `$(DATE)` ..."


# copy-module-content
#    $1 - module
#
# TODO:
# How should the *.map (symbol -> address mappings) and
# the .pdb (debug info) files be packaged?  one for each module
# their .dll resides?  We need to make them available for
# troubleshooting and support purpose.
#
define copy-module-content
  m=$(strip $1); \
  mlib=$(ABS_MODULEPATH_DIR)/$$m ; \
  $(MKDIR) -p $$mlib ; \
  for s in `$(GREP) "^$$m " $(MODULES_LIST)` ; do \
     if [ -d $(ABS_SUBMODULES_DIR)/$$s ] ; then \
         for d in bin lib etc include ; do \
            if [ -d $(ABS_SUBMODULES_DIR)/$$s/$$d ] ; then \
                $(MKDIR) -p $$mlib/$$d ; \
                $(CP) -rf $(ABS_SUBMODULES_DIR)/$$s/$$d/*  $$mlib/$$d; \
            fi ; \
         done \
     fi ; \
  done ; \
  $(FIND) $$mlib -name '*.map' -exec $(RM) \{} \; ; \
  $(FIND) $$mlib -name '*.pdb' -exec $(RM) \{} \; ;
endef

define install-module
  m=$(strip $*); \
  $(RM) -r $(JIGSAW_MODULE_LIB)/$$m ; \
  $(ECHO) "Installing module $$m" ; \
  $(CD) $(MODULEPATH_DIR) && \
  $(HOST_JMOD_CMD) -J-esa install $$m/classes $$m -L $(JIGSAW_MODULE_LIB) $(JMOD_INSTALL_ARGS) || exit 1 ; 
endef

define patch-module-classes
  m=$(strip $*); \
  tmp=$(ABS_MODULES_TEMPDIR)/$$m.files ; \
  $(SED) -e 's%\\%\/%g' $(MODULE_CLASSLIST_DIR)/$$m.classlist > $$tmp || exit 1 ; \
  if [ -f $(MODULE_CLASSLIST_DIR)/$$m.resources ] ; then \
    $(SED) -e 's%\\%\/%g' $(MODULE_CLASSLIST_DIR)/$$m.resources | \
       $(EGREP) -v "default_US_export.policy|default_local.policy|exempt_local.policy" \
       >> $$tmp || exit 1 ; \
  fi ; \
  $(ECHO) "Patching classes for module $$m" ; \
  rsync -v -t --files-from=$$tmp $(ABS_OUTPUTDIR)/classes $(ABS_MODULEPATH_DIR)/$$m/classes || exit 1;
endef

#
# Install the module if module-info.class is updated
# or <module>.summary is updated
#
$(JIGSAW_MODULE_LIB)/%/$(MODULE_VERSION)/info: $(MODULEPATH_DIR)/%/classes/module-info.class \
					       $(MODULE_CLASSLIST_DIR)/%.summary
	@if [ $* = "other" ] ; then \
	    $(ECHO) "ERROR: Check module \"other\". modules.config possibly requires update." ; \
	    exit 1; \
	fi
	@$(call copy-module-content,$*)
	@$(call install-module,$*)
	@$(java-vm-cleanup)

#
# Temporary workaround:
# Copy orb.idl and ir.idl to idlj module
# The *.idl files are imported during the build
#
# A better fix would be in make/common/internal/ImportComponents.gmk
# to install imported files in a module
$(MODULEPATH_DIR)/$(IDLJ_MODULE)/etc/%.idl : $(LIBDIR)/%.idl
	$(install-non-module-file)

clean clobber:: classes.clean
	$(clean-build)


# '<module-name>' development target to update the module content
# of a specific module in the jigsaw module library in the outputdir
# and also in jdk-module-library if exists.
#    $ make jdk.boot
#
# TODO: modify Modularizer to take a parameter to only copy 
# classes and resources for one module
%:
	@if [ `$(GREP) -c "^$@ " $(MODULES_LIST)` != "1" ] ; then \
	    $(ECHO) 'Invalid target: "$@" expected a valid module name' ; \
	    exit 1; \
	fi
	$(call patch-module-classes,$@)
	$(call install-module,$@)
	@$(java-vm-cleanup)
	@if [ -d $(OUTPUTDIR)/jdk-module-image/lib/modules ] ; then \
	    $(RM) -r $(OUTPUTDIR)/jdk-module-image/lib/modules/$@ ; \
	    $(CP) -r $(JIGSAW_MODULE_LIB)/$@ $(OUTPUTDIR)/jdk-module-image/lib/modules/$@ ; \
	fi

.PHONY: modularize module-info-classes

# GNU make bug: make pattern rules delete intermediate files
# Workaround: marks the files as precious
.PRECIOUS: $(MODULEPATH_DIR)/%/classes/module-info.class \
           $(MODULEPATH_DIR)/%/module-info.class \
           $(MODULEPATH_DIR)/%/.modules.update
