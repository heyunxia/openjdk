#
# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Default target declared first
default: all

include $(SPEC)
include MakeBase.gmk
include JavaCompilation.gmk
include Setup.gmk
include ModulesCommon.gmk
include ModulesTools.gmk

THIS_FILE:=GenerateModules.gmk

.NOTPARALLEL:

#
# Modularizing the JDK
# - Post jdk build process until the source tree is restructured
#   for modules build
# - <outputdir>/modules/<module> will be created for each module
# - modules are installed in <outputdir>/lib/modules (jigsaw module
#   library)
#
# Steps:
# 0. During jdk build before this makefile is invoked, classes,
#    resource files, and other non-class files such as native libraries,
#    properties file, images, etc are created.
#
#    Non-class files are copied to <outputdir>/submodules/<MODULE>
#    directory in this step to prepare for the post-build modularization.
#
#    The MODULE variable defined in other makefiles specifies
#    the lowest-level module that the non-class files belong to.
#    The name might or might not be the same as the name of the modules
#    in the resulting <outputdir>/modules directory.
#
# 1. Run ClassAnalyzer tool to analyze all jdk classes and generate
#    class list for all modules and also perform dependency analysis.
#
#    Input configuration files :-
#
#    modules.config : defines the low-level modules and specifies
#       what classes and resource files each module includes.
#    modules.group  : defines the module groups and its members.
#    jdk.depconfig : lists the dynamic dependencies including
#       use of reflection Class.forName and JNI FindClass and
#       service provider.
#    optional.depconfig : lists the optional dependencies
#
#    For incremental build, ClassAnalyzer tool will only parse files
#    that are updated since the last build (by comparing the timestamp
#    of modules.list).
#
# 2. Compile module-info.java files generated by the ClassAnalyzer tool.
#    (only updated module-info.java files for incremental build)
#
# 3. Modularize the JDK.  It creates one directory for each module
#    (<outputdir>/modules/<module>) based on the output files
#    from (1) and also creates a jigsaw module library.
#
#    a. Run Modularizer tool to copy files listed in $m.classlist and
#       $m.resources to <outputdir>/modules/$m/classes and
#       <outputdir>/modules/$m/resources respectively.
#
#       For incremental build, Modularizer tool will only copy files
#       that are modified since the last run (by comparing the timestamp
#       between the source and destination).
#
#    b. copy all non-class files from its members (such as bin, lib, include)
#       to <outputdir>/modules/$m.
#
#       modules.list lists the modules to be created for the modules
#       build and its members.
#
#    c. Install each module in the jigsaw module library
#

# Need to create a jigsaw library in the build lib dir before javac
# will let us compile any modules.
$(JDK_OUTPUTDIR)/lib/modules/%jigsaw-library:
	$(RM) -rf $(@D)
	$(BUILD_JMOD) create -N $(JMOD_CREATE_ARGS) -L $(@D)

# Rules for compiling module-info.java

$(eval $(call SetupJavaCompilation,BUILD_MODULEINFOS,\
    SETUP:=GENERATE_JDK_MODULES,\
    SRC:=$(MODULEINFO_SRC),\
    BIN:=$(MODULEPATH_DIR),\
    ADD_JAVAC_FLAGS:=-Xbootclasspath:"$(MODULARIZER_CLASSPATH)" -modulepath $(MODULEPATH_DIR) -Xlint:-path))

# The jigsaw library must exist before trying to compile the module-infos
# but it doesn't matter if it's newer.
$(BUILD_MODULEINFOS): | $(JDK_OUTPUTDIR)/lib/modules/%jigsaw-library

#  copy module-info.class from modules/$m directory to
#  modules/$m/classes. Default module-info destination for javac
#  multi-module path is <modulepath>/<module>.
$(MODULEPATH_DIR)/%/classes/module-info.class: $(MODULEPATH_DIR)/%/module-info.class
#	@$(install-non-module-file)
	$(install-file)

#
# Modularize JDK and install the modules in the jigsaw library
#
# This "modularize" target can be used as an interim solution
# for incremental build when there is no class added or removed
# since the last run of classanalyzer.
#
modularize:
	@$(ECHO) ">>>Making "$@" @ `$(DATE)` ..."
	$(TOOL_MODULARIZER) \
                -classpath "$(MODULARIZER_CLASSPATH)" \
                -classlistdir $(MODULE_CLASSLIST_DIR) \
                -modulepath $(MODULEPATH_DIR) \
		-update
	$(RM) -rf $(JIGSAW_MODULE_LIB)
	$(BUILD_JMOD) create -N $(JMOD_CREATE_ARGS) -L $(JIGSAW_MODULE_LIB)
	$(MAKE) -f $(THIS_FILE) `$(NAWK) '{print "$(JIGSAW_MODULE_LIB)/" $$1 "/$(MODULE_VERSION)/info" }' $(MODULES_LIST)` || exit 1
	@$(ECHO) ">>>Finished making "$@" @ `$(DATE)` ..."


# copy-module-content
#    $1 - module
#
# TODO:
# How should the *.map (symbol -> address mappings) and
# the .pdb (debug info) files be packaged?  one for each module
# their .dll resides?  We need to make them available for
# troubleshooting and support purpose.
#
define copy-module-content
  m=$(strip $1); \
  mlib=$(MODULEPATH_DIR)/$$m ; \
  $(MKDIR) -p $$mlib ; \
  for s in `$(GREP) "^$$m " $(MODULES_LIST)` ; do \
     if [ -d $(SUBMODULES_DIR)/$$s ] ; then \
         for d in bin lib etc include ; do \
            if [ -d $(SUBMODULES_DIR)/$$s/$$d ] ; then \
                $(MKDIR) -p $$mlib/$$d ; \
                $(CP) -rf $(SUBMODULES_DIR)/$$s/$$d/*  $$mlib/$$d; \
            fi ; \
         done \
     fi ; \
  done ; \
  $(FIND) $$mlib -name '*.map' -exec $(RM) \{} \; ; \
  $(FIND) $$mlib -name '*.pdb' -exec $(RM) \{} \; ;
endef

define install-module
  m=$(strip $*); \
  $(RM) -r $(JIGSAW_MODULE_LIB)/$$m ; \
  $(ECHO) "Installing module $$m" ; \
  $(CD) $(MODULEPATH_DIR) && \
  $(BUILD_JMOD) -J-esa install $$m/classes $$m -L $(JIGSAW_MODULE_LIB) $(JMOD_INSTALL_ARGS) || exit 1 ; 
endef

define patch-module-classes
  m=$(strip $*); \
  tmp=$(OUTPUT_ROOT)/tmp/modules/$$m.files ; \
  $(SED) -e 's%\\%\/%g' $(MODULE_CLASSLIST_DIR)/$$m.classlist > $$tmp || exit 1 ; \
  if [ -f $(MODULE_CLASSLIST_DIR)/$$m.resources ] ; then \
    $(SED) -e 's%\\%\/%g' $(MODULE_CLASSLIST_DIR)/$$m.resources | \
       $(EGREP) -v "default_US_export.policy|default_local.policy|exempt_local.policy" \
       >> $$tmp || exit 1 ; \
  fi ; \
  $(ECHO) "Patching classes for module $$m" ; \
  rsync -v -t --files-from=$$tmp $(JDK_OUTPUTDIR)/classes $(MODULEPATH_DIR)/$$m/classes || exit 1;
endef

#
# Install the module if module-info.class is updated
# or <module>.summary is updated
#
$(JIGSAW_MODULE_LIB)/%/$(MODULE_VERSION)/info: $(MODULEPATH_DIR)/%/classes/module-info.class \
					       $(MODULE_CLASSLIST_DIR)/%.summary
	@if [ $* = "other" ] ; then \
	    $(ECHO) "ERROR: Check module \"other\". modules.config possibly requires update." ; \
	    exit 1; \
	fi
	$(call copy-module-content,$*)
	$(call install-module,$*)

#clean clobber:: classes.clean
#	$(clean-build)


# '<module-name>' development target to update the module content
# of a specific module in the jigsaw module library in the outputdir
# and also in jdk-module-library if exists.
#    $ make jdk.boot
#
# TODO: modify Modularizer to take a parameter to only copy 
# classes and resources for one module
#%:
#	@if [ `$(GREP) -c "^$@ " $(MODULES_LIST)` != "1" ] ; then \
	    $(ECHO) 'Invalid target: "$@" expected a valid module name' ; \
	    exit 1; \
	fi
#	$(call patch-module-classes,$@)
#	$(call install-module,$@)
#	@$(java-vm-cleanup)
#	@if [ -d $(JDK_OUTPUTDIR)/jdk-module-image/lib/modules ] ; then \
	    $(RM) -r $(JDK_OUTPUTDIR)/jdk-module-image/lib/modules/$@ ; \
	    $(CP) -r $(JIGSAW_MODULE_LIB)/$@ $(JDK_OUTPUTDIR)/jdk-module-image/lib/modules/$@ ; \
	fi

all: $(BUILD_MODULEINFOS) $(ORB_IDL) $(IR_IDL) modularize

.PHONY: modularize module-info-classes

# GNU make bug: make pattern rules delete intermediate files
# Workaround: marks the files as precious
.PRECIOUS: $(MODULEPATH_DIR)/%/classes/module-info.class
